package by.example.stepik.JavaBasicСourse.basicJavaSyntax;

import java.math.BigInteger;
import java.util.Arrays;

public class Main {

    public static void main(String[] args) throws Exception {


        /** 2.1. В Григорианском календаре год является високосным в двух случаях: либо он кратен 4, но при этом не кратен 100, либо кратен 400.
         Реализуйте метод, вычисляющий количество високосных лет с начала нашей эры (первого года) до заданного года включительно.
         Предполагается решение без циклов. Вам надо придумать и записать несложную формулу, использующую только арифметические операторы.
         **/
        int year = 1000;
        int number = 4;
        int result = (year / 4) - (year / 100) + (year / 400);
        System.out.println(result);

        /** 2.1. Реализуйте метод, возвращающий ответ на вопрос: правда ли, что a + b = c?
         Допустимая погрешность – 0.0001 (1E-4)
         Можно использовать класс Math и его методы. Класс Math доступен всегда, импортировать его не надо.
         **/
        System.out.println(doubleExpression(0.1, 0.2, 0.3));

        /** 2.1. Реализуйте метод flipBit, изменяющий значение одного бита заданного целого числа на противоположное.
         Данная задача актуальна, например, при работе с битовыми полями.
         Договоримся, что биты нумеруются от младшего (индекс 1) к старшему (индекс 32).
         **/
        System.out.println(flipBit(0, 1));

        /** 2.2. еализуйте метод, который возвращает букву, стоящую в таблице UNICODE после символа "\" (обратный слэш)
         на расстоянии a.
         **/
        System.out.println(charExpression(29));

        /** 2.2. Реализуйте метод, проверяющий, является ли заданное число по абсолютной величине степенью двойки.
         Решать можно разными способами:
         воспользовавшись одним удобным статическим методом из класса java.lang.Integer;
         применив пару трюков из двоичной арифметики;
         написав решение "в лоб" с циклом и условными операторами (можете вернуться к этой задаче после просмотра
         соответствующих уроков).
         **/
        System.out.println(isPowerOfTwo(0));

        /** 2.3. Выберите выражения, которые дадут в качестве результата строку A12
         **/

        System.out.println("A" + 12);
        System.out.println('A' + "12");
        System.out.println("A" + ('\t' + '\u0003'));
        System.out.println('A' + '1' + "2");

        /** 2.3. Реализуйте метод, проверяющий, является ли заданная строка палиндромом.
         Палиндромом называется строка, которая читается одинаково слева направо и справа налево (в том числе пустая).
         При определении "палиндромности" строки должны учитываться только буквы и цифры. А пробелы, знаки препинания,
         а также регистр символов должны игнорироваться. Гарантируется, что в метод попадают только строки, состоящие
         из символов ASCII (цифры, латинские буквы, знаки препинания). Т.е. русских, китайских и прочих экзотических
         символов в строке не будет.

         Подсказки (не читайте, если хотите решить сами):

         для удаления из строки всех символов, не являющихся буквами и цифрами, можно воспользоваться регулярным
         выражением "[^a-zA-Z0-9]";
         найдите в классе String метод, выполняющий замену по регулярному выражению;
         для перестановки символов строки в обратном порядке можно воспользоваться методом reverse(),
         который находится в классе StringBuilder;
         в классе String есть методы для преобразования всей строки в верхний и нижний регистр.
         **/

        System.out.println(isPalindrome("Madam, I'm Adam!"));

        /** 2.4. Реализуйте метод, вычисляющий факториал заданного натурального числа.

         Факториал N вычисляется как 1 ⋅ 2 ⋅ ... ⋅ N.
         Поскольку это очень быстро растущая функция, то даже для небольших
         N вместимости типов int и long очень скоро не хватит. Поэтому будем использовать BigInteger.
         **/

        System.out.println(factorial(10));

        /** 2.4. Реализуйте метод, сливающий два отсортированных по неубыванию массива чисел в один отсортированный в
         том же порядке массив. Массивы могут быть любой длины, в том числе нулевой.

         Предполагается, что вы реализуете алгоритм слияния, имеющий линейную сложность:
         он будет идти по двум исходным массивам и сразу формировать отсортированный результирующий массив.
         Так, чтобы сортировка полученного массива при помощи Arrays.sort() уже не требовалась.
         К сожалению, автоматически это не проверить, так что это остается на вашей совести :)
         **/

        System.out.println(Arrays.toString(mergeArrays(new int[]{0, 2, 2}, new int[]{1, 3})));

        /** 2.4. Вам дан список ролей и сценарий пьесы в виде массива строчек.

         Каждая строчка сценария пьесы дана в следующем виде:
         Роль: текст

         Текст может содержать любые символы.

         Напишите метод, который будет группировать строчки по ролям, пронумеровывать их и возвращать результат
         в виде готового текста (см. пример). Каждая группа распечатывается в следующем виде:

         Роль:
         i) текст
         j) текст2
         ==перевод строки==

         i и j -- номера строк в сценарии. Индексация строчек начинается с единицы, выводить группы следует
         в соответствии с порядком ролей. Переводы строк между группами обязательны, переводы строк в конце текста не учитываются.

         Заметим, что вам предстоит обработка огромной пьесы в 50 000 строк для 10 ролей – соответственно,
         неправильная сборка результирующей строчки может выйти за ограничение по времени.

         Обратите внимание еще на несколько нюансов:

         имя персонажа может встречаться в строке более одного раза, в том числе с двоеточием;
         название одной роли может быть префиксом названия другой роли (например, "Лука" и "Лука Лукич");
         роль, у которой нет реплик, тоже должна присутствовать в выходном файле;
         в качестве перевода строки надо использовать символ '\n' (перевод строки в стиле UNIX);
         будьте внимательны, не добавляйте лишних пробелов в конце строк.
         **/
        System.out.println(printTextPerRole(
                new String[]{
                        "Городничий",
                        "Аммос Федорович",
                        "Артемий Филиппович",
                        "Лука Лукич"},
                new String[]{
                        "Городничий: Я пригласил вас, господа, с тем, чтобы сообщить вам пренеприятное известие: к нам едет ревизор.",
                        "Аммос Федорович: Как ревизор?",
                        "Артемий Филиппович: Как ревизор?",
                        "Городничий: Ревизор из Петербурга, инкогнито. И еще с секретным предписаньем.",
                        "Аммос Федорович: Вот те на!",
                        "Артемий Филиппович: Вот не было заботы, так подай!",
                        "Лука Лукич: Господи боже! еще и с секретным предписаньем!"}));


    }


    public static boolean doubleExpression(double a, double b, double c) {
        return Math.abs((a + b) - c) < 0.0001;
    }

    public static int flipBit(int value, int bitIndex) {
        return 1 << (bitIndex - 1) ^ value;
    }

    public static char charExpression(int a) {
        return (char) (int) ('\\' + a);
    }

    public static boolean isPowerOfTwo(int value) {
        return Integer.toBinaryString(Math.abs(value)).replace("0", "").length() == 1;
    }

    public static boolean isPalindrome(String text) {
        String newString = text.replaceAll("[^a-zA-Z0-9а-яА-Я]", "");  // замена символов не из [] скабок на ""
        // replaceAll() в Java - данный метод заменяет в строке все вхождения подстроки
        StringBuilder sb_newString = new StringBuilder(newString);
        // StringBuilder представляет расширяемые и доступные для изменений последовательности символов, позволяя вставлять
        // символы и подстроки в существующую строку и в любом месте.
        boolean fin = newString.equalsIgnoreCase(sb_newString.reverse().toString());
        /** equalsIgnoreCase – сравнивает данную строку с другой строкой, игнорируя регистр. newString - строка которую сравниваем
         newString - строка с какой сравниваем
         reverse() - меняет порядок в строке на обратный
         toString() – преобразует число в строку
         **/
        return fin;
    }

    public static BigInteger factorial(int value) {
        BigInteger factorial = new BigInteger("1");
        for (int i = 1; i <= value; i++) {
            factorial = factorial.multiply(BigInteger.valueOf(i));
            /** multiply - умножение
             BigInteger.valueOf(i) - преобразование int в BigInteger
             **/
        }
        return factorial;
    }

    public static int[] mergeArrays(int[] a1, int[] a2) {
        int[] result = new int[a1.length + a2.length]; // выделяем память под массив с длиной а1 + а2
        int pos1 = 0;
        int pos2 = 0;
        while (pos1 < a1.length || pos2 < a2.length) {
            result[pos1 + pos2] = (pos1 < a1.length && (pos2 == a2.length || a1[pos1] < a2[pos2]) ?
                    a1[pos1++] : a2[pos2++]);
        }
        return result;
    }

    private static String printTextPerRole(String[] roles, String[] textLines) {
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < roles.length; i++){
            String name = roles[i];
//            result.append(name).append(":").append("\n");
            for (int j = 0; j < textLines.length; j++){
                if (textLines[j].startsWith(name + ":")){
                    result.append(name).append(":").append("\n").append(j + 1).append(") ").append(textLines[j].replaceFirst(name + ": ", "")).append("\n");
                }
            }
            result.append("\n");
        }
        return result.toString();
    }

}
